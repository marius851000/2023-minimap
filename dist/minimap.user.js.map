{"version":3,"file":"minimap.user.js","sources":["../node_modules/uuid/dist/esm-browser/rng.js","../node_modules/uuid/dist/esm-browser/stringify.js","../node_modules/uuid/dist/esm-browser/native.js","../node_modules/uuid/dist/esm-browser/v4.js","../node_modules/@webreflection/mapset/esm/index.js","../node_modules/@webreflection/uparser/esm/index.js","../node_modules/@webreflection/uwire/esm/index.js","../node_modules/uarray/esm/index.js","../node_modules/uhandlers/esm/index.js","../node_modules/uhtml/esm/utils.js","../node_modules/uhtml/esm/handlers.js","../node_modules/udomdiff/esm/index.js","../node_modules/uhtml/esm/rabbit.js","../node_modules/uhtml/esm/index.js"],"sourcesContent":["// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","export class MapSet extends Map {\n  set(key, value) {\n    super.set(key, value);\n    return value;\n  }\n}\n\nexport class WeakMapSet extends WeakMap {\n  set(key, value) {\n    super.set(key, value);\n    return value;\n  }\n}\n","/*! (c) Andrea Giammarchi - ISC */\nconst empty = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\nconst elements = /<([a-z]+[a-z0-9:._-]*)([^>]*?)(\\/?)>/g;\nconst attributes = /([^\\s\\\\>\"'=]+)\\s*=\\s*(['\"]?)\\x01/g;\nconst holes = /[\\x01\\x02]/g;\n\n// \\x01 Node.ELEMENT_NODE\n// \\x02 Node.ATTRIBUTE_NODE\n\n/**\n * Given a template, find holes as both nodes and attributes and\n * return a string with holes as either comment nodes or named attributes.\n * @param {string[]} template a template literal tag array\n * @param {string} prefix prefix to use per each comment/attribute\n * @param {boolean} svg enforces self-closing tags\n * @returns {string} X/HTML with prefixed comments or attributes\n */\nexport default (template, prefix, svg) => {\n  let i = 0;\n  return template\n          .join('\\x01')\n          .trim()\n          .replace(\n            elements,\n            (_, name, attrs, selfClosing) => {\n              let ml = name + attrs.replace(attributes, '\\x02=$2$1').trimEnd();\n              if (selfClosing.length)\n                ml += (svg || empty.test(name)) ? ' /' : ('></' + name);\n              return '<' + ml + '>';\n            }\n          )\n          .replace(\n            holes,\n            hole => hole === '\\x01' ?\n              ('<!--' + prefix + i++ + '-->') :\n              (prefix + i++)\n          );\n};\n","const ELEMENT_NODE = 1;\nconst nodeType = 111;\n\nconst remove = ({firstChild, lastChild}) => {\n  const range = document.createRange();\n  range.setStartAfter(firstChild);\n  range.setEndAfter(lastChild);\n  range.deleteContents();\n  return firstChild;\n};\n\nexport const diffable = (node, operation) => node.nodeType === nodeType ?\n  ((1 / operation) < 0 ?\n    (operation ? remove(node) : node.lastChild) :\n    (operation ? node.valueOf() : node.firstChild)) :\n  node\n;\n\nexport const persistent = fragment => {\n  const {firstChild, lastChild} = fragment;\n  if (firstChild === lastChild)\n    return lastChild || fragment;\n  const {childNodes} = fragment;\n  const nodes = [...childNodes];\n  return {\n    ELEMENT_NODE,\n    nodeType,\n    firstChild,\n    lastChild,\n    valueOf() {\n      if (childNodes.length !== nodes.length)\n        fragment.append(...nodes);\n      return fragment;\n    }\n  };\n};\n","const {isArray} = Array;\nconst {indexOf, slice} = [];\n\nexport {isArray, indexOf, slice};\n","import {isArray} from 'uarray';\n\n// flag for foreign checks (slower path, fast by default)\nlet useForeign = false;\n\nexport class Foreign {\n  constructor(handler, value) {\n    useForeign = true;\n    this._ = (...args) => handler(...args, value);\n  }\n}\n\nexport const foreign = (handler, value) => new Foreign(handler, value);\n\nexport const aria = node => values => {\n  for (const key in values) {\n    const name = key === 'role' ? key : `aria-${key}`;\n    const value = values[key];\n    if (value == null)\n      node.removeAttribute(name);\n    else\n      node.setAttribute(name, value);\n  }\n};\n\nconst getValue = value => value == null ? value : value.valueOf();\n\nexport const attribute = (node, name) => {\n  let oldValue, orphan = true;\n  const attributeNode = document.createAttributeNS(null, name);\n  return newValue => {\n    const value = useForeign && (newValue instanceof Foreign) ?\n                  newValue._(node, name) : getValue(newValue);\n    if (oldValue !== value) {\n      if ((oldValue = value) == null) {\n        if (!orphan) {\n          node.removeAttributeNode(attributeNode);\n          orphan = true;\n        }\n      }\n      else {\n        attributeNode.value = value;\n        if (orphan) {\n          node.setAttributeNodeNS(attributeNode);\n          orphan = false;\n        }\n      }\n    }\n  };\n};\n\nexport const boolean = (node, key, oldValue) => newValue => {\n  const value = !!getValue(newValue);\n  if (oldValue !== value) {\n    // when IE won't be around anymore ...\n    // node.toggleAttribute(key, oldValue = !!value);\n    if ((oldValue = value))\n      node.setAttribute(key, '');\n    else\n      node.removeAttribute(key);\n  }\n};\n\nexport const data = ({dataset}) => values => {\n  for (const key in values) {\n    const value = values[key];\n    if (value == null)\n      delete dataset[key];\n    else\n      dataset[key] = value;\n  }\n};\n\nexport const event = (node, name) => {\n  let oldValue, lower, type = name.slice(2);\n  if (!(name in node) && (lower = name.toLowerCase()) in node)\n    type = lower.slice(2);\n  return newValue => {\n    const info = isArray(newValue) ? newValue : [newValue, false];\n    if (oldValue !== info[0]) {\n      if (oldValue)\n        node.removeEventListener(type, oldValue, info[1]);\n      if (oldValue = info[0])\n        node.addEventListener(type, oldValue, info[1]);\n    }\n  };\n};\n\nexport const ref = node => {\n  let oldValue;\n  return value => {\n    if (oldValue !== value) {\n      oldValue = value;\n      if (typeof value === 'function')\n        value(node);\n      else\n        value.current = node;\n    }\n  };\n};\n\nexport const setter = (node, key) => key === 'dataset' ?\n  data(node) :\n  value => {\n    node[key] = value;\n  };\n\nexport const text = node => {\n  let oldValue;\n  return newValue => {\n    const value = getValue(newValue);\n    if (oldValue != value) {\n      oldValue = value;\n      node.textContent = value == null ? '' : value;\n    }\n  };\n};\n","const {isArray, prototype} = Array;\nconst {indexOf} = prototype;\n\nexport {isArray, indexOf};\n\nconst {\n  createDocumentFragment,\n  createElement,\n  createElementNS,\n  createTextNode,\n  createTreeWalker,\n  importNode\n} = new Proxy(document, {\n  get: (target, method) => target[method].bind(target)\n});\n\nexport {createTextNode, createTreeWalker, importNode};\n\nconst createHTML = html => {\n  const template = createElement('template');\n  template.innerHTML = html;\n  return template.content;\n};\n\nlet xml;\nconst createSVG = svg => {\n  if (!xml) xml = createElementNS('http://www.w3.org/2000/svg', 'svg');\n  xml.innerHTML = svg;\n  const content = createDocumentFragment();\n  content.append(...xml.childNodes);\n  return content;\n};\n\nexport const createContent = (text, svg) => svg ?\n                              createSVG(text) : createHTML(text);\n","import {diffable} from '@webreflection/uwire';\n\nimport {aria, attribute, boolean, event, ref, setter, text} from 'uhandlers';\nimport udomdiff from 'udomdiff';\n\nimport {isArray, createTextNode} from './utils.js';\n\n// from a generic path, retrieves the exact targeted node\nconst reducePath = ({childNodes}, i) => childNodes[i];\n\n// this helper avoid code bloat around handleAnything() callback\nconst diff = (comment, oldNodes, newNodes) => udomdiff(\n  comment.parentNode,\n  // TODO: there is a possible edge case where a node has been\n  //       removed manually, or it was a keyed one, attached\n  //       to a shared reference between renders.\n  //       In this case udomdiff might fail at removing such node\n  //       as its parent won't be the expected one.\n  //       The best way to avoid this issue is to filter oldNodes\n  //       in search of those not live, or not in the current parent\n  //       anymore, but this would require both a change to uwire,\n  //       exposing a parentNode from the firstChild, as example,\n  //       but also a filter per each diff that should exclude nodes\n  //       that are not in there, penalizing performance quite a lot.\n  //       As this has been also a potential issue with domdiff,\n  //       and both lighterhtml and hyperHTML might fail with this\n  //       very specific edge case, I might as well document this possible\n  //       \"diffing shenanigan\" and call it a day.\n  oldNodes,\n  newNodes,\n  diffable,\n  comment\n);\n\n// if an interpolation represents a comment, the whole\n// diffing will be related to such comment.\n// This helper is in charge of understanding how the new\n// content for such interpolation/hole should be updated\nconst handleAnything = comment => {\n  let oldValue, text, nodes = [];\n  const anyContent = newValue => {\n    switch (typeof newValue) {\n      // primitives are handled as text content\n      case 'string':\n      case 'number':\n      case 'boolean':\n        if (oldValue !== newValue) {\n          oldValue = newValue;\n          if (!text)\n            text = createTextNode('');\n          text.data = newValue;\n          nodes = diff(comment, nodes, [text]);\n        }\n        break;\n      // null, and undefined are used to cleanup previous content\n      case 'object':\n      case 'undefined':\n        if (newValue == null) {\n          if (oldValue != newValue) {\n            oldValue = newValue;\n            nodes = diff(comment, nodes, []);\n          }\n          break;\n        }\n        // arrays and nodes have a special treatment\n        if (isArray(newValue)) {\n          oldValue = newValue;\n          // arrays can be used to cleanup, if empty\n          if (newValue.length === 0)\n            nodes = diff(comment, nodes, []);\n          // or diffed, if these contains nodes or \"wires\"\n          else if (typeof newValue[0] === 'object')\n            nodes = diff(comment, nodes, newValue);\n          // in all other cases the content is stringified as is\n          else\n            anyContent(String(newValue));\n          break;\n        }\n        // if the new value is a DOM node, or a wire, and it's\n        // different from the one already live, then it's diffed.\n        // if the node is a fragment, it's appended once via its childNodes\n        // There is no `else` here, meaning if the content\n        // is not expected one, nothing happens, as easy as that.\n        if (oldValue !== newValue) {\n          if ('ELEMENT_NODE' in newValue) {\n            oldValue = newValue;\n            nodes = diff(\n              comment,\n              nodes,\n              newValue.nodeType === 11 ?\n                [...newValue.childNodes] :\n                [newValue]\n            );\n          }\n          else {\n            const value = newValue.valueOf();\n            if (value !== newValue)\n              anyContent(value);\n          }\n        }\n        break;\n      case 'function':\n        anyContent(newValue(comment));\n        break;\n    }\n  };\n  return anyContent;\n};\n\n// attributes can be:\n//  * ref=${...}      for hooks and other purposes\n//  * aria=${...}     for aria attributes\n//  * ?boolean=${...} for boolean attributes\n//  * .dataset=${...} for dataset related attributes\n//  * .setter=${...}  for Custom Elements setters or nodes with setters\n//                    such as buttons, details, options, select, etc\n//  * @event=${...}   to explicitly handle event listeners\n//  * onevent=${...}  to automatically handle event listeners\n//  * generic=${...}  to handle an attribute just like an attribute\nconst handleAttribute = (node, name/*, svg*/) => {\n  switch (name[0]) {\n    case '?': return boolean(node, name.slice(1), false);\n    case '.': return setter(node, name.slice(1));\n    case '@': return event(node, 'on' + name.slice(1));\n    case 'o': if (name[1] === 'n') return event(node, name);\n  }\n\n  switch (name) {\n    case 'ref': return ref(node);\n    case 'aria': return aria(node);\n  }\n\n  return attribute(node, name/*, svg*/);\n};\n\n// each mapped update carries the update type and its path\n// the type is either node, attribute, or text, while\n// the path is how to retrieve the related node to update.\n// In the attribute case, the attribute name is also carried along.\nexport function handlers(options) {\n  const {type, path} = options;\n  const node = path.reduceRight(reducePath, this);\n  return type === 'node' ?\n    handleAnything(node) :\n    (type === 'attr' ?\n      handleAttribute(node, options.name/*, options.svg*/) :\n      text(node));\n};\n","/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * @param {Node} parentNode The container where children live\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nexport default (parentNode, a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd - bStart], 0)) :\n        before;\n      while (bStart < bEnd)\n        parentNode.insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          parentNode.removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      parentNode.insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -1).nextSibling\n      );\n      parentNode.insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap ðŸ‘)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              parentNode.insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            parentNode.replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        parentNode.removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n","import {WeakMapSet} from '@webreflection/mapset';\nimport instrument from '@webreflection/uparser';\nimport {persistent} from '@webreflection/uwire';\n\nimport {handlers} from './handlers.js';\nimport {isArray, indexOf, createContent, createTreeWalker, importNode} from './utils.js';\n\n// from a fragment container, create an array of indexes\n// related to its child nodes, so that it's possible\n// to retrieve later on exact node via reducePath\nconst createPath = node => {\n  const path = [];\n  let {parentNode} = node;\n  while (parentNode) {\n    path.push(indexOf.call(parentNode.childNodes, node));\n    node = parentNode;\n    ({parentNode} = node);\n  }\n  return path;\n};\n\n// the prefix is used to identify either comments, attributes, or nodes\n// that contain the related unique id. In the attribute cases\n// isÂµX=\"attribute-name\" will be used to map current X update to that\n// attribute name, while comments will be like <!--isÂµX-->, to map\n// the update to that specific comment node, hence its parent.\n// style and textarea will have <!--isÂµX--> text content, and are handled\n// directly through text-only updates.\nconst prefix = 'isÂµ';\n\n// Template Literals are unique per scope and static, meaning a template\n// should be parsed once, and once only, as it will always represent the same\n// content, within the exact same amount of updates each time.\n// This cache relates each template to its unique content and updates.\nconst cache = new WeakMapSet;\n\n// a RegExp that helps checking nodes that cannot contain comments\nconst textOnly = /^(?:textarea|script|style|title|plaintext|xmp)$/;\n\nexport const createCache = () => ({\n  stack: [],    // each template gets a stack for each interpolation \"hole\"\n\n  entry: null,  // each entry contains details, such as:\n                //  * the template that is representing\n                //  * the type of node it represents (html or svg)\n                //  * the content fragment with all nodes\n                //  * the list of updates per each node (template holes)\n                //  * the \"wired\" node or fragment that will get updates\n                // if the template or type are different from the previous one\n                // the entry gets re-created each time\n\n  wire: null    // each rendered node represent some wired content and\n                // this reference to the latest one. If different, the node\n                // will be cleaned up and the new \"wire\" will be appended\n});\n\n// the entry stored in the rendered node cache, and per each \"hole\"\nconst createEntry = (type, template) => {\n  const {content, updates} = mapUpdates(type, template);\n  return {type, template, content, updates, wire: null};\n};\n\n// a template is instrumented to be able to retrieve where updates are needed.\n// Each unique template becomes a fragment, cloned once per each other\n// operation based on the same template, i.e. data => html`<p>${data}</p>`\nconst mapTemplate = (type, template) => {\n  const svg = type === 'svg';\n  const text = instrument(template, prefix, svg);\n  const content = createContent(text, svg);\n  // once instrumented and reproduced as fragment, it's crawled\n  // to find out where each update is in the fragment tree\n  const tw = createTreeWalker(content, 1 | 128);\n  const nodes = [];\n  const length = template.length - 1;\n  let i = 0;\n  // updates are searched via unique names, linearly increased across the tree\n  // <div isÂµ0=\"attr\" isÂµ1=\"other\"><!--isÂµ2--><style><!--isÂµ3--</style></div>\n  let search = `${prefix}${i}`;\n  while (i < length) {\n    const node = tw.nextNode();\n    // if not all updates are bound but there's nothing else to crawl\n    // it means that there is something wrong with the template.\n    if (!node)\n      throw `bad template: ${text}`;\n    // if the current node is a comment, and it contains isÂµX\n    // it means the update should take care of any content\n    if (node.nodeType === 8) {\n      // The only comments to be considered are those\n      // which content is exactly the same as the searched one.\n      if (node.data === search) {\n        nodes.push({type: 'node', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n    else {\n      // if the node is not a comment, loop through all its attributes\n      // named isÂµX and relate attribute updates to this node and the\n      // attribute name, retrieved through node.getAttribute(\"isÂµX\")\n      // the isÂµX attribute will be removed as irrelevant for the layout\n      // let svg = -1;\n      while (node.hasAttribute(search)) {\n        nodes.push({\n          type: 'attr',\n          path: createPath(node),\n          name: node.getAttribute(search)\n        });\n        node.removeAttribute(search);\n        search = `${prefix}${++i}`;\n      }\n      // if the node was a style, textarea, or others, check its content\n      // and if it is <!--isÂµX--> then update tex-only this node\n      if (\n        textOnly.test(node.localName) &&\n        node.textContent.trim() === `<!--${search}-->`\n      ){\n        node.textContent = '';\n        nodes.push({type: 'text', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n  }\n  // once all nodes to update, or their attributes, are known, the content\n  // will be cloned in the future to represent the template, and all updates\n  // related to such content retrieved right away without needing to re-crawl\n  // the exact same template, and its content, more than once.\n  return {content, nodes};\n};\n\n// if a template is unknown, perform the previous mapping, otherwise grab\n// its details such as the fragment with all nodes, and updates info.\nconst mapUpdates = (type, template) => {\n  const {content, nodes} = (\n    cache.get(template) ||\n    cache.set(template, mapTemplate(type, template))\n  );\n  // clone deeply the fragment\n  const fragment = importNode(content, true);\n  // and relate an update handler per each node that needs one\n  const updates = nodes.map(handlers, fragment);\n  // return the fragment and all updates to use within its nodes\n  return {content: fragment, updates};\n};\n\n// as html and svg can be nested calls, but no parent node is known\n// until rendered somewhere, the unroll operation is needed to\n// discover what to do with each interpolation, which will result\n// into an update operation.\nexport const unroll = (info, {type, template, values}) => {\n  // interpolations can contain holes and arrays, so these need\n  // to be recursively discovered\n  const length = unrollValues(info, values);\n  let {entry} = info;\n  // if the cache entry is either null or different from the template\n  // and the type this unroll should resolve, create a new entry\n  // assigning a new content fragment and the list of updates.\n  if (!entry || (entry.template !== template || entry.type !== type))\n    info.entry = (entry = createEntry(type, template));\n  const {content, updates, wire} = entry;\n  // even if the fragment and its nodes is not live yet,\n  // it is already possible to update via interpolations values.\n  for (let i = 0; i < length; i++)\n    updates[i](values[i]);\n  // if the entry was new, or representing a different template or type,\n  // create a new persistent entity to use during diffing.\n  // This is simply a DOM node, when the template has a single container,\n  // as in `<p></p>`, or a \"wire\" in `<p></p><p></p>` and similar cases.\n  return wire || (entry.wire = persistent(content));\n};\n\n// the stack retains, per each interpolation value, the cache\n// related to each interpolation value, or null, if the render\n// was conditional and the value is not special (Array or Hole)\nconst unrollValues = ({stack}, values) => {\n  const {length} = values;\n  for (let i = 0; i < length; i++) {\n    const hole = values[i];\n    // each Hole gets unrolled and re-assigned as value\n    // so that domdiff will deal with a node/wire, not with a hole\n    if (hole instanceof Hole)\n      values[i] = unroll(\n        stack[i] || (stack[i] = createCache()),\n        hole\n      );\n    // arrays are recursively resolved so that each entry will contain\n    // also a DOM node or a wire, hence it can be diffed if/when needed\n    else if (isArray(hole))\n      unrollValues(stack[i] || (stack[i] = createCache()), hole);\n    // if the value is nothing special, the stack doesn't need to retain data\n    // this is useful also to cleanup previously retained data, if the value\n    // was a Hole, or an Array, but not anymore, i.e.:\n    // const update = content => html`<div>${content}</div>`;\n    // update(listOfItems); update(null); update(html`hole`)\n    else\n      stack[i] = null;\n  }\n  if (length < stack.length)\n    stack.splice(length);\n  return length;\n};\n\n/**\n * Holds all details wrappers needed to render the content further on.\n * @constructor\n * @param {string} type The hole type, either `html` or `svg`.\n * @param {string[]} template The template literals used to the define the content.\n * @param {Array} values Zero, one, or more interpolated values to render.\n */\nexport class Hole {\n  constructor(type, template, values) {\n    this.type = type;\n    this.template = template;\n    this.values = values;\n  }\n};\n","import {MapSet, WeakMapSet} from '@webreflection/mapset';\n\nimport {Hole, createCache, unroll} from './rabbit.js';\n\n// both `html` and `svg` template literal tags are polluted\n// with a `for(ref[, id])` and a `node` tag too\nconst tag = type => {\n  // both `html` and `svg` tags have their own cache\n  const keyed = new WeakMapSet;\n  // keyed operations always re-use the same cache and unroll\n  // the template and its interpolations right away\n  const fixed = cache => (template, ...values) => unroll(\n    cache,\n    {type, template, values}\n  );\n  return Object.assign(\n    // non keyed operations are recognized as instance of Hole\n    // during the \"unroll\", recursively resolved and updated\n    (template, ...values) => new Hole(type, template, values),\n    {\n      // keyed operations need a reference object, usually the parent node\n      // which is showing keyed results, and optionally a unique id per each\n      // related node, handy with JSON results and mutable list of objects\n      // that usually carry a unique identifier\n      for(ref, id) {\n        const memo = keyed.get(ref) || keyed.set(ref, new MapSet);\n        return memo.get(id) || memo.set(id, fixed(createCache()));\n      },\n      // it is possible to create one-off content out of the box via node tag\n      // this might return the single created node, or a fragment with all\n      // nodes present at the root level and, of course, their child nodes\n      node: (template, ...values) => unroll(createCache(), new Hole(type, template, values)).valueOf()\n    }\n  );\n};\n\n// each rendered node gets its own cache\nconst cache = new WeakMapSet;\n\n// rendering means understanding what `html` or `svg` tags returned\n// and it relates a specific node to its own unique cache.\n// Each time the content to render changes, the node is cleaned up\n// and the new new content is appended, and if such content is a Hole\n// then it's \"unrolled\" to resolve all its inner nodes.\nconst render = (where, what) => {\n  const hole = typeof what === 'function' ? what() : what;\n  const info = cache.get(where) || cache.set(where, createCache());\n  const wire = hole instanceof Hole ? unroll(info, hole) : hole;\n  if (wire !== info.wire) {\n    info.wire = wire;\n    // valueOf() simply returns the node itself, but in case it was a \"wire\"\n    // it will eventually re-append all nodes to its fragment so that such\n    // fragment can be re-appended many times in a meaningful way\n    // (wires are basically persistent fragments facades with special behavior)\n    where.replaceChildren(wire.valueOf());\n  }\n  return where;\n};\n\nconst html = tag('html');\nconst svg = tag('svg');\n\nexport {Hole, render, html, svg};\n"],"names":["getRandomValues","rnds8","Uint8Array","rng","crypto","bind","Error","byteToHex","i","push","toString","slice","native","randomUUID","v4","options","buf","offset","rnds","random","arr","toLowerCase","unsafeStringify","MapSet","Map","set","key","value","super","WeakMapSet","WeakMap","empty","elements","attributes","holes","diffable","node","operation","nodeType","firstChild","lastChild","range","document","createRange","setStartAfter","setEndAfter","deleteContents","remove","valueOf","isArray","Array","getValue","event","name","oldValue","lower","type","newValue","info","removeEventListener","addEventListener","prototype","indexOf","createDocumentFragment","createElement","createElementNS","createTextNode","createTreeWalker","importNode","Proxy","get","target","method","xml","createContent","text","svg","innerHTML","content","append","childNodes","createSVG","html","template","createHTML","reducePath","diff","comment","oldNodes","newNodes","parentNode","a","b","before","bLength","length","aEnd","bEnd","aStart","bStart","map","insertBefore","has","removeChild","nextSibling","index","sequence","replaceChild","udomdiff","handleAttribute","setAttribute","removeAttribute","boolean","dataset","values","data","setter","current","ref","aria","orphan","attributeNode","createAttributeNS","removeAttributeNode","setAttributeNodeNS","attribute","handlers","path","reduceRight","this","nodes","anyContent","String","handleAnything","textContent","createPath","call","prefix","cache","textOnly","mapTemplate","join","trim","replace","_","attrs","selfClosing","ml","trimEnd","test","hole","instrument","tw","search","nextNode","hasAttribute","getAttribute","localName","mapUpdates","fragment","updates","unroll","unrollValues","entry","wire","createEntry","ELEMENT_NODE","persistent","stack","Hole","splice","constructor","tag","keyed","Object","assign","for","id","memo","fixed","where","what","replaceChildren"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13]}